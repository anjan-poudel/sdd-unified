# SDD Unified: Enhancement Proposal

**Version:** 1.0.0  
**Status:** Future Roadmap  
**Last Updated:** 2025-10-16

## Overview

This document proposes critical enhancements to address fundamental architectural gaps identified during competitive analysis. These are not optional features but foundational pillars required for long-term viability.

## Current Status

sdd-unified v1.0.0-alpha provides:
- ✅ Declarative workflow DAG
- ✅ Multi-agent orchestration  
- ✅ Task-driven BDD implementation
- ✅ Formal iterative reviews
- ✅ Context management

**However**, competitive analysis revealed three critical gaps that limit production readiness.

---

## Proposal 1: Machine-Readable Specification

### The Problem

Current "specifications" (`spec.md`, `requirements.md`) are prose documents that:
- Are ambiguous and interpretation-dependent
- Cannot be programmatically verified
- Make the framework "suggestion-driven" not "specification-driven"
- Undermine verifiability principles

### Inspiration: spec-kit

The core lesson: A specification in an AI-driven system must be a **machine-readable contract**, not a document for humans.

### First-Principles Justification

Specification-Driven Development requires that the specification *drives* the process. This is only possible if the specification is an executable artifact that validates every subsequent step. A prose document allows ambiguity, leading to non-determinism.

**To build a reliable system, the foundation must be reliable.**

### Implementation

#### 1. Introduce `spec.yaml`

New mandatory artifact generated by `ba/define-requirements`:

```yaml
# spec.yaml
version: "1.0"
feature:
  id: "feature-001-auth"
  name: "User Authentication"
  
components:
  - id: "auth-service"
    type: "microservice"
    responsibilities:
      - "JWT token generation"
      - "User authentication"
    
  - id: "user-service"
    type: "microservice"
    responsibilities:
      - "User CRUD operations"
      
data_structures:
  - name: "User"
    fields:
      - name: "id"
        type: "UUID"
        required: true
      - name: "email"
        type: "string"
        required: true
        validation: "email_format"
        
api_endpoints:
  - path: "/auth/login"
    method: "POST"
    input: "LoginRequest"
    output: "AuthToken"
    
validation_rules:
  - rule: "email_format"
    pattern: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
```

#### 2. Schema Definition

Versioned JSON schema at `sdd-unified/spec/spec.schema.json`:

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["version", "feature", "components"],
  "properties": {
    "version": {"type": "string"},
    "feature": {
      "type": "object",
      "required": ["id", "name"],
      "properties": {
        "id": {"type": "string"},
        "name": {"type": "string"}
      }
    },
    "components": {
      "type": "array",
      "items": {"$ref": "#/definitions/component"}
    }
  }
}
```

#### 3. Agent Contracts

All subsequent agents must:
- Read and parse `spec.yaml`
- Reference entities from spec in their outputs
- Maintain traceability to spec requirements

**Example L1 Architecture:**
```markdown
# L1 Architecture

## Components

### Auth Service (spec.components[0])
Implements JWT token generation and user authentication as defined in spec.yaml.

Interfaces:
- POST /auth/login (spec.api_endpoints[0])
```

#### 4. Automated Validation

New `Validator` module in framework:

```python
class SpecValidator:
    def validate_l1_design(self, spec_yaml, l1_md):
        # Check all spec.components appear in L1
        # Check all spec.api_endpoints are addressed
        # Return validation report
        pass
```

Integration into workflow:

```json
{
  "id": "validate-l1",
  "type": "validation",
  "validator": "SpecValidator.validate_l1_design",
  "inputs": ["spec/spec.yaml", "design/l1_architecture.md"],
  "on_failure": "halt_workflow"
}
```

---

## Proposal 2: Standardized Human-in-the-Loop

### The Problem

Current workflow is a "black box":
- Human initiates and waits for output
- No structured intervention points during execution
- Cannot leverage human expertise for course correction
- Brittle process with no quality checkpoints

### Inspiration: BMAD

Key insight: Human review gates should be first-class, codified steps in the workflow.

### First-Principles Justification

A purely automated system cannot account for all nuance and context. Stratified Abstraction provides natural checkpoints for verification. By formalizing human review at these checkpoints, we transform oversight from reactive to proactive.

**Process integrity requires human validation at key abstraction boundaries.**

### Implementation

#### 1. Review Gate Annotation

New field in command definitions:

```yaml
# commands/architect/design-l1.yaml
name: design-l1
description: Create L1 architecture
agent: sdd-architect
review_gate:
  required: true
  reviewers: ["sdd-ba", "sdd-pe", "sdd-le"]
  type: "manual" | "automated" | "hybrid"
outputs:
  - design/l1_architecture.md
```

#### 2. Workflow Blocking

When orchestrator encounters review gate:
1. Complete the command
2. Mark artifact as `pending_review`
3. Block workflow progression
4. Notify required reviewers

#### 3. Formal Review Commands

New command class:

```yaml
# commands/ba/review-design-l1.yaml
name: review-design-l1
description: BA review of L1 architecture
agent: sdd-ba
type: review_command
inputs:
  - design/l1_architecture.md
  - spec/spec.yaml
checklist:
  - "Aligns with requirements"
  - "Addresses all functional needs"
  - "NFRs considered"
outcomes:
  - APPROVED
  - REJECTED_WITH_FEEDBACK
outputs:
  - review/review_l1_ba.json
```

#### 4. State Transition

Review command produces outcome file:

```json
{
  "status": "APPROVED" | "REJECTED_WITH_FEEDBACK",
  "reviewer": "sdd-ba",
  "timestamp": "...",
  "feedback": "..."
}
```

Orchestrator:
- Subscribes to review outcome files
- APPROVED → Unblocks workflow
- REJECTED → Triggers rework command

---

## Proposal 3: Decoupled Agent Runtime

### The Problem

Agents are functions called by monolithic orchestrator:
- Tight coupling between workflow and execution
- Difficult to maintain
- Prevents sophisticated patterns (parallel, async, specialist critics)
- All innovation must conform to single execution model

### Inspiration: AgentOS

Core principle: Separate agent execution environment (runtime) from workflow definition.

### First-Principles Justification

Robust systems require separation of concerns. The "what" (workflow sequence) should be decoupled from the "how" (agent invocation mechanism). A monolithic engine forces all future innovations to conform to one hardcoded model.

**Clean architecture enables evolution without rewrites.**

### Implementation

#### 1. Event Bus

Implement in-process message queue:

```python
class EventBus:
    def __init__(self):
        self.subscribers = {}
    
    def publish(self, event_type, payload):
        for handler in self.subscribers.get(event_type, []):
            handler(payload)
    
    def subscribe(self, event_type, handler):
        self.subscribers.setdefault(event_type, []).append(handler)
```

#### 2. Tasks as Events

Orchestrator publishes task events:

```python
# Instead of:
architect_agent.design_l1(spec_path)

# Do:
event_bus.publish("L1_DESIGN_REQUIRED", {
    "spec_path": "spec/spec.yaml",
    "output_path": "design/l1_architecture.md"
})
```

#### 3. Agents as Services

Agents subscribe to task events:

```python
class ArchitectAgent:
    def __init__(self, event_bus):
        event_bus.subscribe("L1_DESIGN_REQUIRED", self.handle_l1_design)
    
    def handle_l1_design(self, payload):
        # Do work
        result = self.design_l1(payload["spec_path"])
        
        # Publish completion
        event_bus.publish("L1_DESIGN_COMPLETED", {
            "artifact_path": payload["output_path"],
            "status": "success"
        })
```

#### 4. Results as Events

Orchestrator subscribes to completion events:

```python
event_bus.subscribe("L1_DESIGN_COMPLETED", workflow.on_l1_complete)
```

**Benefits:**
- Multiple agents can subscribe to same event (parallel work)
- Agents can be in different processes (distributed)
- Easy to add specialist agents (e.g., security critic)
- Workflow and execution fully decoupled

---

## Implementation Priority

### Phase 1: Machine-Readable Spec (Weeks 1-4)
**Criticality:** HIGH  
**Effort:** Medium  
**Impact:** Enables true specification-driven development

**Deliverables:**
- spec.yaml schema definition
- BA agent generates spec.yaml
- Basic validator for L1 design

### Phase 2: Human-in-the-Loop (Weeks 5-8)
**Criticality:** HIGH  
**Effort:** Medium  
**Impact:** Process integrity and quality gates

**Deliverables:**
- Review gate annotations
- Workflow blocking mechanism
- Formal review commands
- State transition handling

### Phase 3: Event-Driven Runtime (Weeks 9-16)
**Criticality:** MEDIUM  
**Effort:** High  
**Impact:** Enables parallel processing and extensibility

**Deliverables:**
- Event bus implementation
- Agent service refactoring
- Parallel task execution
- Distributed agent support

---

## Success Criteria

### Machine-Readable Spec
- ✅ 100% of design artifacts reference spec.yaml entities
- ✅ Automated validation catches misalignment
- ✅ Spec changes trigger design updates

### Human-in-the-Loop
- ✅ All design phases have formal review gates
- ✅ Workflow blocks until review complete
- ✅ Review feedback tracked in audit trail

### Decoupled Runtime
- ✅ Agents can run in parallel
- ✅ New agent types can be added without orchestrator changes
- ✅ Event-driven architecture fully operational

---

## Risks and Mitigations

### Risk: Increased Complexity

**Mitigation:**
- Implement incrementally
- Maintain backward compatibility
- Comprehensive documentation
- Example workflows

### Risk: Validation Overhead

**Mitigation:**
- Cache validation results
- Incremental validation
- Configurable validation levels

### Risk: Event Bus Performance

**Mitigation:**
- Start with in-process (fast)
- Profile before optimizing
- Async where beneficial

---

## Conclusion

These three enhancements address fundamental gaps:

1. **Machine-Readable Spec** → True specification-driven development
2. **Human-in-the-Loop** → Process integrity and quality assurance
3. **Decoupled Runtime** → Extensibility and parallel processing

Together, they transform sdd-unified from a proof-of-concept into a production-grade framework.

**Recommended Action:** Implement Phase 1 immediately after core validation completes.

---

**Document Version:** 1.0.0  
**Last Updated:** 2025-10-16  
**Owner:** sdd-unified Enhancement Team