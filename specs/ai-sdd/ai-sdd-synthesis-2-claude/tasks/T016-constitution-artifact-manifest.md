# T016: Constitution Artifact Manifest

**Phase:** 1 (Core Engine)
**Status:** PENDING
**Dependencies:** T003 (constitution system), T004 (core engine)
**Size:** XS (2 days)
**Replaces:** ContextReducer (removed — see GAPS-ANALYSIS.md GAP-L2-005)

---

## Context

Context window growth is managed through the **pull model**: agents read what they need
using their native tools, rather than the engine pushing everything into context.

The engine's role is simple: after each task completes, write an auto-updated
**artifact manifest section** into the project's `constitution.md`. Agents read the manifest
to discover what artifacts exist, then use their native tools to read only the relevant sections.

No ContextReducer. No summarizer. No embedding pipeline. ~50 lines of code.

---

## Acceptance Criteria

```gherkin
Feature: Constitution artifact manifest

  Scenario: Manifest written after task completes
    Given task "define-requirements" completes and produces requirements.md
    When the engine runs the post-task manifest writer hook
    Then the "## Workflow Artifacts" section in constitution.md is updated
    And requirements.md appears in the manifest with status COMPLETED

  Scenario: Manifest reflects full workflow state
    Given a workflow with 4 completed tasks and 2 pending
    When any agent reads constitution.md
    Then it sees a manifest table with all 6 tasks, correct paths, and statuses

  Scenario: Manifest section is machine-parseable
    Given the manifest section in constitution.md
    When the engine reads it back
    Then it can parse the table without ambiguity
    And the data matches the workflow state file

  Scenario: Constitution reading convention instructs agents
    Given the constitution template
    When it is loaded into any agent's context
    Then the "Reading Convention" section tells the agent to read only relevant artifacts
    And lists the native tools to use (Read, Grep, Serena search_for_pattern, etc.)

  Scenario: Manifest section is idempotent
    Given the manifest writer runs twice on the same state
    When both runs complete
    Then the constitution.md contains exactly one manifest section
    And the second run replaces the first (not appends)

  Scenario: Missing constitution.md — manifest section is created
    Given a project with no constitution.md
    When the manifest writer runs for the first time
    Then a minimal constitution.md is created with the manifest section
    And a warning is emitted: "no project constitution found; created minimal one"
```

---

## Manifest Format

The engine manages a `## Workflow Artifacts` section in the project's root `constitution.md`:

```markdown
## Workflow Artifacts
<!-- AUTO-GENERATED by ai-sdd — do not edit this section manually -->
<!-- Last updated: 2026-02-27T11:30:00Z by engine after task: design-l1 -->

| Task | Artifact | Path | Status |
|---|---|---|---|
| define-requirements | Requirements doc | .ai-sdd/outputs/requirements.md | COMPLETED |
| design-l1 | L1 Architecture | .ai-sdd/outputs/design/l1.md | COMPLETED |
| review-l1 | Review log | .ai-sdd/outputs/review/l1.json | COMPLETED |
| design-l2 | L2 Component Design | .ai-sdd/outputs/design/l2.md | PENDING |
| implement | Implementation | .ai-sdd/outputs/implementation/ | PENDING |

## Reading Convention
<!-- AUTO-GENERATED — describes how agents should use this manifest -->
You have access to all COMPLETED artifacts above via your native tools.
Read only the artifacts relevant to your current task.
Do not pre-load all artifacts — read the specific sections you need.

Available tools for reading artifacts:
- Read a file: use your file read tool on the path above
- Search for specific content: use your grep/search tool
- Get structure of a code file: use Serena get_symbols_overview
- Find a specific section: search for the heading text
```

---

## Implementation

The manifest writer is a post-task hook registered with the engine:

```python
# constitution/manifest_writer.py

def write_artifact_manifest(constitution_path: Path, workflow_state: WorkflowState) -> None:
    """
    Write/replace the ## Workflow Artifacts section in constitution.md.
    Uses begin/end markers for idempotent replacement.
    ~50 lines. No external dependencies.
    """
    manifest_lines = [
        "## Workflow Artifacts",
        "<!-- AUTO-GENERATED by ai-sdd — do not edit this section manually -->",
        f"<!-- Last updated: {datetime.utcnow().isoformat()}Z -->",
        "",
        "| Task | Artifact | Path | Status |",
        "|---|---|---|---|",
    ]
    for task_id, task in workflow_state.tasks.items():
        for output in task.outputs:
            manifest_lines.append(
                f"| {task_id} | {output.description} | {output.path} | {task.status} |"
            )
    _replace_section(constitution_path, "## Workflow Artifacts", manifest_lines)
    # Engine owns ONLY ## Workflow Artifacts.
    # ## Reading Convention is user-authored in constitution.md and never touched.
```

The writer is registered as a `post_task` hook in the engine:
```python
engine.on_post_task("*", manifest_writer.write_artifact_manifest)
```

---

## Manifest Ownership Contract

The engine owns **exactly one section**: `## Workflow Artifacts`.
It never reads, writes, or touches any other section in constitution.md.

`## Reading Convention` is user-authored. Teams write it once at project init and
the engine never modifies it. This avoids the ambiguity of "engine owns both but
preserves user edits" — there are no user edits to the manifest, and the engine
has no opinion about how agents should read artifacts.

For Claude Code projects, the reading convention should reference Claude Code's native tools:
```markdown
## Reading Convention
Read only the artifacts relevant to your current task.
Use the Read tool for specific files.
Use Grep to find relevant sections within a large document.
Use Serena's get_symbols_overview for generated code files.
```

For Roo Code projects, the MCP server exposes `get_constitution()` which returns the
merged constitution including the current manifest.

---

## Files to Create

- `constitution/manifest_writer.py`
- `tests/test_manifest_writer.py`
- Updated `constitution/resolver.py` — exclude AUTO-GENERATED sections from merge
  (manifest is per-project; it should not be inherited by sub-modules)

---

## Test Strategy

- Unit tests: manifest written correctly; idempotent (run twice → one section).
- Unit tests: missing constitution.md → created with manifest only.
- Unit tests: AUTO-GENERATED sections excluded from sub-module inheritance.
- Integration test: full workflow run → manifest reflects correct state at each step.

## Rollback/Fallback

- If manifest write fails: emit warning, continue (manifest is observability, not state).
- If constitution.md is read-only: emit warning; manifest update skipped.
